<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Pixel Tetris</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">

<style>
html,body{
  margin:0;
  padding:0;
  background:#000;
  overflow:hidden;
  touch-action:none;
  font-family:monospace;
}
canvas{
  display:block;
  margin:auto;
  background:#111;
  image-rendering:pixelated;
}
#controls{
  position:fixed;
  bottom:10px;
  width:100%;
  display:flex;
  justify-content:space-around;
  flex-wrap:wrap;
}
.btn{
  width:60px;
  height:60px;
  background:#333;
  color:#fff;
  border-radius:50%;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:22px;
  user-select:none;
  margin:4px;
}
.small{width:50px;height:50px;font-size:14px;}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="controls">
  <div class="btn" id="left">‚óÄ</div>
  <div class="btn" id="rotate">‚ü≥</div>
  <div class="btn" id="right">‚ñ∂</div>
  <div class="btn" id="down">‚ñº</div>
  <div class="btn small" id="pause">‚è∏</div>
  <div class="btn small" id="restart">‚ü≤</div>
  <div class="btn small" id="music">üéµ</div>
</div>

<script>
if ("serviceWorker" in navigator) navigator.serviceWorker.register("sw.js");

// ---------- CANVAS ----------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const COLS=10, ROWS=20, BLOCK=24;
canvas.width = COLS*BLOCK;
canvas.height = ROWS*BLOCK;

// ---------- AUDIO ----------
let audioCtx, musicOsc, musicGain, musicTimer;
function beep(f,d){
  if(!audioCtx) audioCtx=new (window.AudioContext||webkitAudioContext)();
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  o.type="square"; o.frequency.value=f;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+d);
  o.stop(audioCtx.currentTime+d);
}

// NES benzeri basit melodi
const melody=[659,494,523,587,523,494,440];
let note=0;
function startMusic(){
  if(!audioCtx) audioCtx=new (window.AudioContext||webkitAudioContext)();
  if(musicOsc) return;
  musicOsc=audioCtx.createOscillator();
  musicGain=audioCtx.createGain();
  musicOsc.type="square";
  musicGain.gain.value=0.03;
  musicOsc.connect(musicGain);
  musicGain.connect(audioCtx.destination);
  musicOsc.start();
  musicTimer=setInterval(()=>{
    musicOsc.frequency.value=melody[note++%melody.length];
  },300);
}
function stopMusic(){
  if(musicOsc){musicOsc.stop(); musicOsc=null;}
  clearInterval(musicTimer);
}

// ---------- GAME STATE ----------
let grid = Array.from({length:ROWS},()=>Array(COLS).fill(0));
let score=0, lines=0, level=1;
let high=localStorage.high||0;
let paused=false, gameOver=false;

const PIECES=[
  {s:[[1,1,1,1]],c:"cyan"},
  {s:[[2,2],[2,2]],c:"yellow"},
  {s:[[0,3,0],[3,3,3]],c:"purple"},
  {s:[[0,4,4],[4,4,0]],c:"green"},
  {s:[[5,5,0],[0,5,5]],c:"red"},
  {s:[[6,0,0],[6,6,6]],c:"blue"},
  {s:[[0,0,7],[7,7,7]],c:"orange"}
];

function newPiece(){
  const p=PIECES[Math.floor(Math.random()*PIECES.length)];
  return {x:3,y:0,shape:p.s,color:p.c};
}

let cur=newPiece(), next=newPiece();
let dropCounter=0, dropInterval=700, last=0;

// ---------- DRAW ----------
function drawBlock(x,y,c,alpha=1){
  ctx.globalAlpha=alpha;
  ctx.fillStyle=c;
  ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
  ctx.strokeStyle="#111";
  ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
  ctx.globalAlpha=1;
}

function ghostY(){
  let y=cur.y;
  while(!collide({...cur,y:y+1})) y++;
  return y;
}

function draw(){
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  grid.forEach((r,y)=>r.forEach((v,x)=>v&&drawBlock(x,y,v)));

  // Ghost piece
  const gy=ghostY();
  cur.shape.forEach((r,y)=>r.forEach((v,x)=>v&&drawBlock(cur.x+x,gy+y,cur.color,0.3)));

  // Active piece
  cur.shape.forEach((r,y)=>r.forEach((v,x)=>v&&drawBlock(cur.x+x,cur.y+y,cur.color)));

  ctx.fillStyle="#fff";
  ctx.fillText(`SKOR: ${score}`,10,20);
  ctx.fillText(`SEVƒ∞YE: ${level}`,10,40);
  ctx.fillText(`REKOR: ${high}`,10,60);
  if(paused) ctx.fillText("PAUSE",10,90);
  if(gameOver) ctx.fillText("GAME OVER",10,90);
}

// ---------- LOGIC ----------
function collide(p){
  return p.shape.some((r,y)=>r.some((v,x)=>{
    if(!v) return false;
    let nx=p.x+x, ny=p.y+y;
    return ny>=ROWS||nx<0||nx>=COLS||grid[ny][nx];
  }));
}

function merge(){
  cur.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) grid[cur.y+y][cur.x+x]=cur.color;
  }));
  beep(300,0.05);
}

function rotate(){
  const old=cur.shape;
  const rows=old.length, cols=old[0].length;
  let res=[];
  for(let c=0;c<cols;c++){
    res[c]=[];
    for(let r=rows-1;r>=0;r--) res[c].push(old[r][c]);
  }
  cur.shape=res;
  if(collide(cur)) cur.shape=old;
  else beep(700,0.05);
}

function clearLines(){
  let cleared=0;
  for(let y=ROWS-1;y>=0;y--){
    if(grid[y].every(v=>v)){
      grid.splice(y,1);
      grid.unshift(Array(COLS).fill(0));
      cleared++; y++;
    }
  }
  if(cleared){
    lines+=cleared;
    score+=cleared*10*level;
    level=1+Math.floor(lines/10);
    dropInterval=Math.max(150,700-level*70);
    high=Math.max(high,score);
    localStorage.high=high;
    beep(500,0.1);
  }
}

function drop(){
  cur.y++;
  if(collide(cur)){
    cur.y--;
    merge();
    clearLines();
    cur=next;
    next=newPiece();
    if(collide(cur)) gameOver=true;
  }
}

// ---------- CONTROLS ----------
["left","right","down","rotate","pause","restart"].forEach(id=>{
  document.getElementById(id).ontouchstart=()=>{
    audioCtx?.resume();
    startMusic();
    if(id==="left"){cur.x--; if(collide(cur)) cur.x++;}
    if(id==="right"){cur.x++; if(collide(cur)) cur.x--;}
    if(id==="down") drop();
    if(id==="rotate") rotate();
    if(id==="pause"){paused=!paused; paused?stopMusic():startMusic();}
    if(id==="restart") location.reload();
  };
});

// ---------- LOOP ----------
function update(t=0){
  if(paused||gameOver){draw(); requestAnimationFrame(update); return;}
  let d=t-last; last=t;
  dropCounter+=d;
  if(dropCounter>dropInterval){drop(); dropCounter=0;}
  draw();
  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>